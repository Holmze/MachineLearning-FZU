from sklearn.metrics import accuracy_score, normalized_mutual_info_score, adjusted_rand_scoreimport PIL.Image as Imagefrom sklearn.cluster import KMeansfrom clustering_performance import clusteringMetricsimport randomimport matplotlib.pyplot as pltimport numpy as npimport osIMAGES_PATH_DIR = os.getcwd() + r"\face_images\\"IMAGES_FORMAT = ['.jpg', '.py']IMAGE_SIZE = (200,180)IMAGE_ROW = 10IMAGE_COLUMN = 20IMAGE_SAVE_PATH = 'Image_cluster_.jpg'def loadData(FileName):    im = Image.open(FileName)    im = im.convert('RGB')    return imdata_show = plt.figure(1)plt.title("The picture")image_names = []image_vector = []real_label = sorted([_ for _ in range(0, 10)]*20)to_image = Image.new('RGB', (IMAGE_SIZE[1]*IMAGE_COLUMN, IMAGE_SIZE[0]*IMAGE_ROW))image_dir_names = [name for name in os.listdir(IMAGES_PATH_DIR) if os.path.splitext(name)[1] not in IMAGES_FORMAT ]# print(image_dir_names)for x, dir_name in enumerate(image_dir_names):    new_addr = IMAGES_PATH_DIR + dir_name + '\\'    image_names = [name for name in os.listdir(new_addr) if os.path.splitext(name)[1] in IMAGES_FORMAT ]    # print(image_names)            for y, _PATH in enumerate(image_names):        IMAGES_PATH = new_addr + _PATH        # print(IMAGES_PATH)        im = loadData(IMAGES_PATH)        from_image = im.resize(( IMAGE_SIZE[1], IMAGE_SIZE[0] ), Image.ANTIALIAS)        to_image.paste(from_image, (y * IMAGE_SIZE[1], x * IMAGE_SIZE[0]))        image_vector.append(list(im.getdata()))image_vector = np.array(image_vector).ravel().reshape((200, -1))print(image_vector)k=10km = KMeans(n_clusters=k)pre_label = km.fit_predict(image_vector)print(pre_label.shape)print("The real data label is ", real_label)print("The predict data label is ", pre_label)print("ACC = {0}, NMI = {1}, ARI = {2}".format(*clusteringMetrics(real_label, pre_label)))to_image.save(IMAGE_SAVE_PATH)plt.imshow(to_image)plt.show()'''def distance(v1, v2):    return np.sqrt(sum((v1-v2)**2))def initCentroids(data, k):    NumSamples, dim = data.shape    centroids = np.zeros((k, dim))    for i in range(k):        index = random.randint(0, NumSamples)        centroids[i, :] = data[index, :]    return centroidsdef k_means(data, k):    NumSamples = data.shape[0]    clusterData = np.array( np.zeros((NumSamples, 2)) )    clusterChanged = True    centroids = initCentroids(data, k)    while clusterChanged:        clusterChanged = False        for i in range(NumSamples):            minDist = 100000.0            minIndex = 0            for j in range(k):                dist = distance(centroids[j, :], data[i, :])                if dist < minDist:                    minDist = dist                    clusterData[i, 1] = minDist                    minIndex = j            if clusterData[i, 0] != minIndex:                clusterChanged = True                clusterData[i, 0] = minIndex        for j in range(k):            cluster_index= np.nonzero(clusterData[:, 0]==j)            PointsInCluster = data[cluster_index]            centroids[j, :] = np.mean(PointsInCluster, axis=0)    return centroids, clusterData      k=10data, label = make_blobs(n_samples=400, centers=k)data_show = plt.figure(1)plt.subplot(1,2,1)plt.title("K-Means 1")plt.scatter(data[:, 0], data[:, 1], c=label[:]) plt.subplot(1,2,2)plt.title("K-Means 2")centroids, clusterData = k_means(data, k)while np.isnan(centroids).any():    centroids, clusterData = k_means(data, k)plt.scatter(data[:, 0], data[:, 1], c=clusterData[:, 0])# plt.scatter(centroids[:, 0], centroids[:, 1], c='b', marker='*')for i in range(k):    plt.plot(centroids[i, 0], centroids[i, 1], '*b', markersize=20)plt.show()'''